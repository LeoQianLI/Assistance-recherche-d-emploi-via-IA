import tempfile
import streamlit as st
import os
import time
from crewai_tools import FileReadTool, MDXSearchTool, SerperDevTool, ScrapeWebsiteTool
from crewai import Agent, Crew, Process, Task, LLM
from crewai.project import CrewBase, agent, crew, task
from models_st import JobRequirements, ResumeOptimization, CompanyResearch
from litellm.exceptions import RateLimitError

def get_llm(model_name, system_prompt=None):
    """Get LLM instance with fallback options"""
    try:
        # Try to get model from environment variable
        model = os.getenv("LLM_MODEL", "gpt-3.5-turbo")
        return LLM(model=model, system_prompt=system_prompt)
    except Exception as e:
        st.warning(f"Failed to initialize {model_name}, trying fallback models...")
        # Try different fallback models in order of preference
        fallback_models = [
            "gpt-3.5-turbo",  # OpenAI (gratuit avec limite)
            "claude-2",       # Anthropic (gratuit avec limite)
            "mistral/mistral-7b-instruct",  # Mistral (gratuit)
            "gemini/gemini-1.0-pro"  # Google (gratuit avec limite)
        ]
        
        for fallback_model in fallback_models:
            try:
                st.info(f"Attempting to use {fallback_model} as fallback...")
                return LLM(model=fallback_model, system_prompt=system_prompt)
            except Exception as inner_e:
                st.warning(f"Failed to initialize {fallback_model}: {str(inner_e)}")
                continue
        
        # If all fallbacks fail, raise the original error
        raise e

def retry_with_backoff(func, max_retries=3, initial_delay=5):
    """Retry a function with exponential backoff and longer delays"""
    delay = initial_delay
    for attempt in range(max_retries):
        try:
            return func()
        except RateLimitError as e:
            if attempt == max_retries - 1:
                raise e
            st.warning(f"Rate limit reached. Retrying in {delay} seconds... (Attempt {attempt + 1}/{max_retries})")
            time.sleep(delay)
            delay *= 2  # Exponential backoff
            if delay > 30:  # Cap the maximum delay at 30 seconds
                delay = 30

# create a liens related to the resume_text in the file crewai_st.py

if "resume_text" in st.session_state and st.session_state.resume_text:
    resume_text = st.session_state['selected_job']
    resume_t = st.session_state.resume_text
    # Create a temporary file for CV content
    with tempfile.NamedTemporaryFile(
        delete=False, suffix=".txt", mode="w", encoding="utf-8"
    ) as temp_file:
        temp_file.write(resume_t)
        temp_file_path = temp_file.name

    # Initialize tools with temporary file
    read_resume = FileReadTool(file_path=temp_file_path)
    sematic_search_resume = MDXSearchTool(mdx=temp_file_path)

    @CrewBase
    class Gojob:
        """Gojob crew"""

        @agent
        def resume_analyzer(self) -> Agent:
            return Agent(
                verbose=True,
                groq_llm=get_llm("resume_analyzer", "RÃ©pondez uniquement en franÃ§ais."),
                tools=[read_resume, sematic_search_resume],
                role="Expert en optimisation de CV",
                goal="Analyser les CV et fournir des suggestions d'optimisation structurÃ©es en franÃ§ais",
                backstory="""Vous Ãªtes un spÃ©cialiste de l'optimisation de CV avec une connaissance approfondie des systÃ¨mes ATS
et des meilleures pratiques modernes en matiÃ¨re de CV. Vous excellez dans l'analyse des CV PDF et
la fourniture de suggestions d'amÃ©lioration concrÃ¨tes. Vos recommandations se concentrent toujours
sur la lisibilitÃ© humaine et la compatibilitÃ© ATS.ğŸŸ¢ **TOUTES VOS RÃ‰PONSES DOIVENT ÃŠTRE EN FRANÃ‡AIS.**""",
            )

        @agent
        def job_analyzer(self) -> Agent:
            return Agent(
                verbose=True,
                tools=[ScrapeWebsiteTool(),read_resume, sematic_search_resume],
                groq_llm=get_llm("job_analyzer"),
                role="Analyste des exigences de poste",
                goal="Analyser les descriptions de poste et Ã©valuer l'adÃ©quation des candidats en franÃ§ais",
                backstory="""Vous Ãªtes un expert en analyse du marchÃ© du travail et en Ã©valuation des candidats. Votre force
rÃ©side dans la dÃ©composition des exigences de poste en catÃ©gories claires et la fourniture
d'une Ã©valuation dÃ©taillÃ©e basÃ©e sur les qualifications des candidats. Vous comprenez Ã  la fois les
compÃ©tences techniques et gÃ©nÃ©rales, et pouvez Ã©valuer avec prÃ©cision les niveaux d'expÃ©rience.ğŸŸ¢ **TOUTES VOS RÃ‰PONSES DOIVENT ÃŠTRE EN FRANÃ‡AIS.**""",
            )

        @agent
        def company_researcher(self) -> Agent:
            return Agent(
                verbose=True,
                tools=[SerperDevTool(), read_resume, sematic_search_resume],
                groq_llm=get_llm("company_researcher"),
                role="SpÃ©cialiste en intelligence d'entreprise",
                goal="Rechercher des informations sur les entreprises et prÃ©parer des insights pour les entretiens en franÃ§ais",
                backstory="""Vous Ãªtes un expert en recherche d'entreprise qui excelle dans la collecte et l'analyse
des derniÃ¨res informations sur les entreprises. Vous savez comment trouver et synthÃ©tiser des donnÃ©es
provenant de diverses sources pour crÃ©er des profils d'entreprise complets et prÃ©parer
les candidats aux entretiens.ğŸŸ¢ **TOUTES VOS RÃ‰PONSES DOIVENT ÃŠTRE EN FRANÃ‡AIS.**""",
            )

        @agent
        def resume_writer(self) -> Agent:
            return Agent(
                verbose=True,
                llm=get_llm("resume_writer"),
                tools=[SerperDevTool(), read_resume, sematic_search_resume],
                role="SpÃ©cialiste en rÃ©daction de CV en markdown",
                goal="CrÃ©er des CV formatÃ©s en markdown, optimisÃ©s pour les ATS en franÃ§ais",
                backstory="""Vous Ãªtes un expert en rÃ©daction de CV spÃ©cialisÃ© dans la crÃ©ation de CV formatÃ©s en markdown.
                Vous savez comment transformer des suggestions d'optimisation structurÃ©es en documents
                formatÃ©s en markdown, optimisÃ©s pour les ATS, qui maintiennent le professionnalisme
                tout en mettant en valeur les points forts des candidats.ğŸŸ¢ **TOUTES VOS RÃ‰PONSES DOIVENT ÃŠTRE EN FRANÃ‡AIS.**""",
            )

        @agent
        def report_generator(self) -> Agent:
            return Agent(
                verbose=True,
                llm=get_llm("report_generator"),
                tools=[SerperDevTool(), read_resume, sematic_search_resume],
                role="GÃ©nÃ©rateur de rapports de carriÃ¨re et spÃ©cialiste du markdown",
                goal="CrÃ©er des rapports complets, visuellement attrayants et exploitables Ã  partir de l'analyse des candidatures en franÃ§ais",
                backstory="""Vous Ãªtes un expert en visualisation de donnÃ©es, rÃ©daction technique et formatage markdown.
                Vous excellez dans la combinaison de donnÃ©es provenant de multiples sources JSON pour crÃ©er des rapports
                cohÃ©rents et visuellement attrayants. Votre spÃ©cialitÃ© est de transformer des analyses structurÃ©es
                en insights clairs et exploitables avec un formatage markdown appropriÃ©, des emojis et
                des Ã©lÃ©ments visuels qui rendent l'information Ã  la fois attrayante et facilement digestible.ğŸŸ¢ **TOUTES VOS RÃ‰PONSES DOIVENT ÃŠTRE EN FRANÃ‡AIS.**""",
            )

        @task
        def analyze_job_task(self) -> Task:
            return Task(
                agent=self.job_analyzer(),
                output_file="output/job_analysis.json",
                output_pydantic=JobRequirements,
                description="""Analyser la description du poste et Ã©valuer l'adÃ©quation du candidat en fonction de son CV.
                                Sortie en JSON structurÃ©.
                                Ajouter des emojis et des Ã©lÃ©ments visuels pour amÃ©liorer la lisibilitÃ©.
                                Si la longueur de la phrase atteint 94 caractÃ¨res, veuillez passer la ligne suivante.
                                1. Extraire les exigences : compÃ©tences techniques, gÃ©nÃ©rales, expÃ©rience, Ã©ducation, connaissance du secteur.
                                2. Ã‰valuer les compÃ©tences techniques et gÃ©nÃ©rales.
                                3. Ã‰valuer l'expÃ©rience et l'Ã©ducation.
                                4. Calculer le score global.""",
                expected_output="DonnÃ©es JSON structurÃ©es contenant l'analyse du poste et les dÃ©tails de l'Ã©valuation.",
            )

        @task
        def optimize_resume_task(self) -> Task:
            return Task(
                agent=self.resume_analyzer(),
                output_file="output/resume_optimization.json",
                output_pydantic=ResumeOptimization,
                description="""Examiner le {read_resume} uploaded en fonction de l'analyse du poste et crÃ©er des suggestions d'optimisation structurÃ©es.
                                Sortie en JSON structurÃ©.
                                Ajouter des emojis et des Ã©lÃ©ments visuels pour amÃ©liorer la lisibilitÃ©.
                                Si la longueur de la phrase atteint 94 caractÃ¨res, veuillez passer la ligne suivante.
                                1. Analyser le contenu et la structure du CV.
                                2. GÃ©nÃ©rer des suggestions d'amÃ©lioration.
                                3. LE CV DOIT ÃŠTRE GÃ‰NÃ‰RÃ‰ EN FRANÃ‡AIS SEULEMENT.""",
                expected_output="DonnÃ©es JSON structurÃ©es contenant des suggestions d'optimisation dÃ©taillÃ©es.",
                context= [self.analyze_job_task()]
            )

        @task
        def research_company_task(self) -> Task:
            return Task(
                agent=self.company_researcher(),
                output_file="output/company_research.json",
                output_pydantic=CompanyResearch,
                description="""Rechercher des informations sur l'entreprise et prÃ©parer une analyse complÃ¨te.
                            Sortie en JSON structurÃ©.
                            Ajouter des emojis et des Ã©lÃ©ments visuels pour amÃ©liorer la lisibilitÃ©.
                            Si la longueur de la phrase atteint 94 caractÃ¨res, veuillez passer la ligne suivante.
                            1. PrÃ©sentation de l'entreprise : dÃ©veloppements rÃ©cents, culture, position sur le marchÃ©.
                            2. PrÃ©paration Ã  l'entretien : questions courantes, sujets spÃ©cifiques, projets rÃ©cents.""",
                expected_output="DonnÃ©es JSON structurÃ©es contenant les rÃ©sultats de la recherche sur l'entreprise.",
            )

        @task
        def generate_resume_task(self) -> Task:
            return Task(
                agent=self.resume_writer(),
                output_file="output/optimized_resume.md",
                description=f"""Utiliser le contenu du CV original et les suggestions d'optimisation pour crÃ©er un CV optimisÃ© en markdown.
                                Contenu du CV original:
                                {resume_t}
                                
                                Instructions:
                                1. IntÃ©grer le contenu original du CV
                                2. Appliquer les suggestions d'optimisation
                                3. Formater en markdown
                                4. Ajouter des emojis et des Ã©lÃ©ments visuels
                                5. LE CV DOIT ÃŠTRE GÃ‰NÃ‰RÃ‰ EN FRANÃ‡AIS SEULEMENT
                                6. Ne pas ajouter de blocs de code markdown comme '```'
                                7. Si la longueur de la phrase atteint 94 caractÃ¨res, passer Ã  la ligne suivante""",
                expected_output="Un document de CV au format markdown bien prÃ©sentÃ©, incorporant le contenu original et les suggestions d'optimisation.",
                context= [self.optimize_resume_task(), self.analyze_job_task(), self.research_company_task()]
            )

        @task
        def generate_report_task(self) -> Task:
            return Task(
                agent=self.report_generator(),
                output_file="output/final_report.md",
                description="""CrÃ©er un rapport de synthÃ¨se exÃ©cutif en utilisant les donnÃ©es des Ã©tapes prÃ©cÃ©dentes.
                            Formater en markdown sans blocs de code '```'.
                            Ajouter des emojis et des Ã©lÃ©ments visuels pour amÃ©liorer la lisibilitÃ©.
                            Si la longueur de la phrase atteint 94 caractÃ¨res, veuillez passer la ligne suivante.
                            1. IntÃ©grer les donnÃ©es : analyse du poste, optimisation du CV, insights sur l'entreprise.
                            2. Structurer le rapport : rÃ©sumÃ© exÃ©cutif, analyse de l'adÃ©quation, aperÃ§u de l'optimisation, insights sur l'entreprise, prochaines Ã©tapes.
                            3. LE final_report DOIT ÃŠTRE GÃ‰NÃ‰RÃ‰ EN FRANÃ‡AIS SEULEMENT.""",
                expected_output=""" Un rapport markdown complet combinant toutes les analyses en un document clair et exploitable.""",
                context= [self.analyze_job_task(), self.optimize_resume_task(), self.research_company_task()]
            )

        @crew
        def crew(self) -> Crew:
            agents_instances = [
                self.resume_analyzer(),
                self.job_analyzer(),
                self.company_researcher(),
                self.resume_writer(),
                self.report_generator(),
            ]
            tasks_instances = [
                self.analyze_job_task(),
                self.optimize_resume_task(),
                self.research_company_task(),
                self.generate_resume_task(),
                self.generate_report_task(),
            ]
            return Crew(
                agents=agents_instances,
                tasks=tasks_instances,
                verbose=True,
                process=Process.sequential,
                tools=[read_resume, sematic_search_resume],
            )

    try:
        # Execute the crew with retry logic
        gojob = Gojob()
        crew_instance = gojob.crew()
        
        def execute_crew():
            return crew_instance.kickoff()
        
        # Execute with retry logic and longer initial delay
        result = retry_with_backoff(execute_crew, max_retries=3, initial_delay=5)

        # Display the final report and optimized resume
        report_file = r"C:\Users\leo12\Documents\Projet3\Assistance-recherche-d-emploi-via-IA\src\gojob\output\final_report.md"
        optimized_resume_file = r"C:\Users\leo12\Documents\Projet3\Assistance-recherche-d-emploi-via-IA\src\gojob\output\optimized_resume.md"
        
        if os.path.exists(report_file) and os.path.exists(optimized_resume_file):
            with open(report_file, "r", encoding="utf-8") as file:
                final_report = file.read()
            with open(optimized_resume_file, "r", encoding="utf-8") as file:
                optimized_resume = file.read()
            st.markdown(final_report, unsafe_allow_html=True)
            st.markdown(optimized_resume, unsafe_allow_html=True)
            st.success("Rapport gÃ©nÃ©rÃ© avec succÃ¨s!")
        else:
            st.error(f"Le fichier de rapport {report_file} n'existe pas.")
            
    except RateLimitError as e:
        st.error("""Nous avons atteint la limite de requÃªtes pour le moment. 
                   Le systÃ¨me va essayer d'utiliser un autre modÃ¨le d'IA.
                   Si le problÃ¨me persiste, veuillez rÃ©essayer dans quelques minutes.
                   Conseil: Attendez environ 5 minutes avant de rÃ©essayer.""")
        st.error(f"Erreur dÃ©taillÃ©e: {str(e)}")
        # Try to reinitialize with a different model
        try:
            st.info("Tentative de rÃ©initialisation avec un modÃ¨le alternatif...")
            gojob = Gojob()
            crew_instance = gojob.crew()
            result = crew_instance.kickoff()
            st.success("OpÃ©ration rÃ©ussie avec le modÃ¨le alternatif!")
        except Exception as fallback_error:
            st.error("Ã‰chec de l'utilisation du modÃ¨le alternatif. Veuillez rÃ©essayer plus tard.")
            st.error(f"Erreur dÃ©taillÃ©e: {str(fallback_error)}")
    except Exception as e:
        st.error("Une erreur inattendue s'est produite. Veuillez rÃ©essayer.")
        st.error(f"Erreur dÃ©taillÃ©e: {str(e)}")

